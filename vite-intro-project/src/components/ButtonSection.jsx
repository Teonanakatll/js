import { useState } from "react";
import Button from "./Button/Button"
import { differences } from "../data";

export default function ButtonSection() {
 // всегда обьявляется внутри компонента и находится на верхнем уровне, никаких условий не допускается при обьявлении стейтов
  // состояние всегда принадлежит компоненту, в котором оно объявлено. Если бы handleClick был внутри Button, он не смог бы менять content в App.
  // первый элемент это начальное состояние, второй элемент это функция которая меняет состояние стейта
  const [ contentType, setContentType ] = useState(null)

  function handleClick(type) {
    console.log(`${type}  button clicked`);
    //ВАЖНО - ЗНАЧЕНИЕ В contentType ИЗМЕНИТСЯ ТОЛЬКО ПРИ СЛЕДУЮЩЕМ РЕНДЕРЕ СТРАНИЦЫ

    // при клике на кнопку меняем состояние обьекта с помощю функции setContent, так как при клике на 
    // кнопку обновляется состояние переменной context то реакт отслеживает изменение состояние этой 
    // переменной и гдебы она не находилась на странице данные с ней перерисовываются, даже если эта 
    // переменная всего лиш является ключом с помощю которого из какого то обьекта  берутся различные данные
    setContentType(type)
  }

  let tabContent = null 
  // функция выводит значение стейта
  if (contentType) {
    tabContent = <p>{differences[contentType]}</p>
  } else {
    tabContent = <p>Нажми на кнопку</p>
  }

	return (
		<section>
			<h3>Чем мы отличаемся от других</h3>
			<p>{/* Передача функции-обработчика через пропсы — это способ сообщить дочерним компонентам, что должно происходить в 
			родительском компоненте при взаимодействии с ними. Это позволяет сохранить гибкость и чистоту кода, а также делает компоненты переиспользуемыми. 
			в кнопку передаётся только ссылка на функцию, кнопка при клике вызывает функцию обработчик именно буквально в компоненте в котором и обьявленна 
			функция обработчик, тоесть запускает её компонент кнопки а отрабатывает она в компоненте app и поэтому корректно изменяются стейты,

			Стрелочная функция (() => {}) позволяет добавить дополнительную логику или аргументы в вызов функции, 
			когда она передаётся в качестве обработчика события

			Чистота логики: Логика обработки и состояния остается в одном месте (в родительском компоненте).
			Переиспользуемость: Ты можешь использовать компонент Button в разных местах, передавая ему разные обработчики.
			Гибкость: Родительский компонент может менять логику работы с событиями, а дочерний компонент не зависит от изменений внутри родителя.

			название пропса должно совпадать с названием слушателя в компаненте чтобы с помощю ... rest собрать оставшиеся 
			пропсы и распаковать их с помощю ... spred
			*/}</p>
					<Button isAct={contentType === 'way'} onClick={() => handleClick('way')}>Подход</Button>
			<Button isAct={contentType === 'easy'} onClick={() => handleClick('easy')}>Доступность</Button>
			<Button isAct={contentType === 'program'} onClick={() => handleClick('program')}>Концентрация</Button>

			{/* при клике на кнопку в тег P передаём значение из обьекта со стейтами в котором с помощю ключа полученного от кнопки получаем
			значение стейта сывязанного с этой кнопкой, кратко при клике получаем ключ - по ключу получаем значение параметра из обьекта стейтов
			*/}
			{/* {contentType ? (<p>{differences[contentType]}</p>) : (<div>Нажми на кнопку</div>)} */}
			{/* <p>{differences[contentType]}</p> */}

			{/* В JavaScript оператор && возвращает первое ложное или последнее истинное значение (а не просто True/False)
			если слева истинное то вернётся правое */}
			{!contentType && <p>Нажми на кнопку</p>}
			{contentType && <p>{differences[contentType]}</p>}

			{/* {tabContent} */}

	</section>
	)
}